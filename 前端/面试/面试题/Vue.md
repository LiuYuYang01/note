# Vue

## Vue 的最大的优势是什么？

`Vue` 是一款轻量级前端框架，简单易学、数据双向绑定、支持组件化开发、数据与视图完全分离、虚拟DOM运行速度更快 并且作者尤雨溪是中国人，Vue相应的文档也是中文的，对国内比较友好。所以Vue是前端开发人员首选的入门框架



**Vue的优势：**

1. 支持组件化开发，提高代码复用性以及扩展性
2. 虚拟 `Dom`，提高网站性能
3. 数据双向绑定，数据发生变化既视图发生变化
4. 数据与视图完全分离，提高代码可读性



## Vue3 性能提升主要是通过哪几方面体现的？

**体积变小**

相比 `Vue2` 它的体积变小了，它移除了一些不常用的 `API`，还有就是任何一个函数，比如 `ref`、`reactive`、`computed` 等仅在用到时候才会打包，如果哪个模块没有用到就不会打包了，这样会使整体体积变小



**响应式系统**

看下面



## Vue2 与 Vue3的响应式有什么区别？

`Vue2` 采用的是 `Object.defineProperty`，因为它需要遍历对象的所有属性，并将他们转换为 `getter`、`setter`，这样会导致性能不太友好

而 `Vue3` 采用的是 `proxy`，它是在整个对象上做代理操作，也就是说不需要遍历对象的所有属性，而是直接拦截对整个对象。因此它的性能要比 `Object.defineProperty` 高。因为他是 `ES6` 才新增的语法，所以这种方式对兼容上不太友好



## Vue 项目中如何解决跨域问题？

**反向代理**

可以在 `vue.config.js` 中配置反向代理实现跨域，核心实现思路就是给 `proxy` 中新增一个字符串形式的 `"/api"` 作为键，他的值需要设置一个目标地址，也就是需要跨域的地址，然后在访问后端接口时需要加上 `/api` 前缀，这样就会代理到服务器从而实现跨域

```javascript
module.exports = {
    devServer: {
        host: '127.0.0.1',
        port: 8084,
        open: true,// vue项目启动时自动打开浏览器
        proxy: {
            '/api': { // '/api'是代理标识，用于告诉node，url前面是/api的就是使用代理的
                target: "http://xxx.xxx.xx.xx:8080", //目标地址，一般是指后台服务器地址
                changeOrigin: true, //是否跨域
                pathRewrite: { // pathRewrite 的作用是把实际Request Url中的'/api'用""代替
                    '^/api': "" 
                }
            }
        }
    }
}
```



**后端实现**

后端只需要配置一下请求头或者导入现成的包就可以实现跨域



**JSONP**

可以采用 `JSONP` 方式来实现跨域，不过这种方式只支持 `GET` 请求，他的跨域原理简单来说就是利用前端的 `script` 标签，因为这个标签本身就支持跨域，我们可以利用这个标签的 `src` 属性指向服务器接口的地址，这样在页面加载时就会自动触发该接口

然后在服务器接口中返回一个字符串形式的函数调用，将前端需要的数据通过函数实参传递，而这个函数要与前端的函数相匹配，这样就能调用它 拿到后端的数据了

**详情看这里：** https://blog.csdn.net/TKOP_/article/details/115915920



## SPA 单页面应用的优缺点

**优点**

1. 用户体验好，内容的改变不需要加载整个页面，有效减轻服务器压力
2. 前后端分离开发模式 前端进行界面交互逻辑，后端负责数据处理 有效提高代码可读性
3. 组件化开发提高项目复用性以及扩展性



**缺点**

1. 对 SEO 不太友好，前后端分离模式在前端没有渲染数据相当于没有 SEO
2. 不能使用浏览器自带的前进后退功能，需要自己通过 `router` 定义
3. 首次访问页面需要加载大量的静态资源，加载时间相对较长



## Vue 与 jQuery 的区别

`jQuery` 是直接操作的真实 `DOM` 需要先获取元素然后进行赋值，数据与视图是在一起的

而 `Vue` 操作的是虚拟 `DOM` 并且将数据与视图完全分离了



## Vue 的常用指令

1. `v-bind`：动态绑定数据
2. `v-on`：绑定事件监听器
3. `v-for`：循环指令，可以循环数组或对象
4. `v-model`：实现双向绑定
5. `v-if`：根据表达式的真假值，判断是否渲染元素，会销毁并重建
6. `v-show`：显示隐藏元素，修改元素的 `display` 属性



## Vue 常用的修饰符

**.stop：** 阻止事件冒泡
**.prevent： ** 阻止默认行为
**.capture：** 与事件冒泡的方向相反，事件捕获由外到内
**.self：** 只有被绑定事件的那个元素才能被触发
**.once：** 使该事件只触发一次



## Vue ref 和 reactive 的区别

1. `ref` 既可以定义基本类型也可以定义引用类型的数据，而 `reactive` 只能用来定义引用类型数据

2. `ref` 定义的数据需要通过 `.value` 来读取或更新 `reactive` 可以直接操作数据
3. `ref ` 定义的数据如果是引用数据类型，它的底层其实是通过 `reactive` 来定义的



## Vue 性能优化有哪方面

**一、尽可能使用 v-show 替换 v-if**

因为 `v-show` 本质上是通过 `css` 控制元素的显示与隐藏，而 `v-if` 是通过操作 `dom` 来控制元素的显示与隐藏，频繁操作 `dom` 会导致性能有所影响



**二、使用路由懒加载**

```javascript
{
    path: '/login',
    component: () => import('@/views/login/index'),
}
```

1. **减轻初始加载：** 通过路由懒加载，只有在使用到对应的页面时才会加载相关的代码。这样可以减少初始加载的代码量，提升网页的加载速度，特别是在应用有很多页面的情况下效果更为明显。
2. **提升页面加载速度：** 当用户访问某个具体的页面时，只需要加载该页面所需的代码，而不是一次性加载所有页面的代码。这样可以减少请求的网络带宽和内存占用，提升页面加载速度，给用户更好的体验。
3. **优化资源利用：** 路由懒加载可以将应用划分为多个独立的模块，每个模块可以按需加载，提高代码的复用性和可维护性。同时，由于只加载当前需要的模块，可以更好地控制资源的使用，避免一次性加载过多的资源。

**简单来说：** 路由懒加载可以让网站加载更快，提高用户体验，同时也更好地利用资源、提高代码可维护性。



**三、引入网络资源**

可以将静态资源放在第三方 `CDN` 服务器上，比如 `css`、`js`、图片、视频、字体等

这样做有以下好处：

1. 提高页面加载速度
2. 减少项目打包之后的体积
3. 利用浏览器缓存，不变动的文件长期缓存



**四、尽可能使用按需导入**

在项目中尽可能避免 `*` 导入全部而是使用按需导入，否则就会导入很多我们用不到的东西从而影响项目打包的体积大小以及页面加载速度。



**五、icon 使用精灵图**

默认情况下页面中有几张图片就会发起几次请求，所以我们可以将图片全部合成在一张图中，然后通过操作 `CSS` 的 `background` 属性，控制背景的位置以及大小，来展示需要的部分。这样可以减少 `HTTP` 请求压力



**销毁资源**

使用完某些代码后一定要销毁资源，比如定时器。一般在 `beforeDestroy` 中销毁。这样可以避免资源浪费以及内存泄露



**使用 v-for 必须添加 key**

在删除数据时，由于没有绑定 `key`，不确定删除的是哪个，就会把整个虚拟 `dom` 重新渲染，这样对性能不太友好。

但如果设置了 `key`，比如 `k` 的值为 `x`，那么在删除数据时候只会把 `dom` 为 `x` 的数据删掉，并不会重新渲染整个 `dom`。这样一来对性能有很大的提高



**避免 v-for 与 v-if 一起使用**

当 `v-for` 和 `v-if` 结合使用时，`Vue` 需要在每次渲染时都重新计算列表中每个元素是否满足 `v-if` 的条件，这会导致不必要的性能开销。

如果将 `v-if` 放在父元素上时，`v-for` 会在每次重新渲染时都完整遍历整个列表，判断每个元素是否满足条件。这样也会导致性能下降，尤其在列表较大时更为明显。

为了避免这种性能问题，推荐的做法是将 `v-if` 放在包裹在元素内部，而不是包裹在元素上，这样可以减少不必要的遍历次数，提升性能。

```html
<div v-for="item in data" :key="item.id">
  <div v-if="item.condition">
    <!-- 具体元素内容 -->
  </div>
</div>
```



**合理使用 watch 和 computed**

`watch` 适用于执行异步或开销较大的操作，或者需要对数据变化作出特定响应的场景。

`computed` 用于根据已有的响应式数据计算出一个新的值，它会根据相关的响应式数据进行缓存，只在相关响应式数据改变时进行重新计算。这样可以避免不必要的重复计算，提高性能。

**简单来说：** 使用 `watch` 监听数据变化，适合处理复杂操作或需要特定响应的情况；使用 `computed` 计算属性，可以根据已有数据计算新值并自动缓存，提高性能。合理使用这两个功能可以让代码更易读和更高效。



**使用懒加载**

使用懒加载可以优化同一时间减少 `http` 请求开销。

比如页面加载时让他先加载部分数据，等用户点击下一页或下拉之后再加载另一部分数据



**使用节流防抖**

节流：在一定时间间隔内只执行一次函数

```javascript
function throttle(func, delay) {
  let timer = null;
  return function() {
    if (!timer) {
      timer = setTimeout(() => {
        func.apply(this, arguments);
        timer = null;
      }, delay);
    }
  };
}
```



防抖：在一定时间内不能被再次触发

```javascript
function debounce(func, delay) {
  let timer = null;
  return function() {
    clearTimeout(timer);
    timer = setTimeout(() => {
      func.apply(this, arguments);
    }, delay);
  };
}
```



使用

```javascript
function onScroll() {
  console.log("Scroll event");
}

// 使用节流函数
const throttledScroll = throttle(onScroll, 200);
window.addEventListener("scroll", throttledScroll);

// 使用防抖函数
const debouncedScroll = debounce(onScroll, 200);
window.addEventListener("scroll", debouncedScroll);
```



这两种技术可以在事件处理、滚动加载、搜索框输入等场景下有效地减少不必要的计算和操作，提升页面性能和用户体验。



**组件缓存**

组件缓存是指将组件的状态缓存起来，当组件再次被渲染时，可以直接使用缓存的状态，而不需要重新渲染组件。

组件缓存的优势在于减少了组件的渲染次数，从而降低了开销。它对于包含大量静态内容的组件，如轮播图、静态文章等组件的性能优化特别有效。因为这些组件的内容往往不会随着数据变化而发生改变，使用组件缓存可以将组件的渲染次数降至最低。



## Vue watch 和 watchEffect 的区别

1. `watch` 可以访问新值和旧值(如果监视对象的话不行，因为新旧值相等)，`watchEffect` 只能监听最新的值。

2. `watch` 需要监听指定的属性，而 `watchEffect` 会监听所有属性值的变化，所以属性过多情况下不建议使用，会影响性能

3. `watch` 只有监听的属性值发生变化了才会触发，而 `watchEffect` 会默认触发一次。`watch` 需要在第三个参数中指定 `immediate:true` 才会默认触发一次



## Vue 数据响应式原理是什么

**Vue2** 响应式原理是遍历 `data` 对象中的每一个属性，如果是基本数据类型就直接通过 `Object.defineProperty` 把 `data` 对象上的每个属性转换具有 `getter` 和 `setter` 的拦截器属性。

如果遍历的是复杂数据类型，则需要递归变量，`Object.defineProperty` 把 `data` 对象上的每个属性转换具有 `getter` 和 `setter` 的拦截器属性



**总结**

`Vue2` 是通过 `Object.defineProperty` 把每一个属性都转换为响应式，如果有 100 个属性就要遍历 100 次，而 `Vue3` 则是把整个对象给 `proxy` 转换为响应式，如果有 100 个属性也只遍历一次。

前者需要遍历全部，而后者只需要遍历一次，所以后者 `Vue3` 性能更佳



## Vue computed 和 watch 属性的区别以及应用场景

**区别**

1、计算属性具有缓存功能，只有当依赖的值发生变化时才会触发，而侦听属性没有缓存，只要值被修改就会触发

2、计算属性不支持异步，而侦听属性支持异步

3、计算属性必须要有return 返回值，而 侦听属性不能写return 会导致获取不到数据

 

**应用场景**  

**watch：** 一个数据影响多个数据，需要在数据变化时执行异步操作或者开销较大的操作时使用。

例如搜索数据

**computed：** 一个数据受到多个数据影响，处理复杂逻辑或多个属性影响一个属性变化时候使用。

例如购物车商品结算功能



## Vue 组件的 data 为什么必须是函数

组件中的 `data` 函数返回值形式定义，这样每复用组件时就会返回一个新的 `data`，相当于给每个组件实例创建一个互不影响的私有数据空间。而写成对象形式就会导致所有组件实例共用了一个 `data`，就会造成一个数据发生变化，所有 `data` 数据都会变化这种情况



## Vue组件之间的通信有几种方式

1. props：父组件可以通过 `props` 属性传递数据给子组件。子组件可以通过 `props` 选项接收并使用这些数据。
2. $emit：子组件可以通过 `$emit` 方法触发自定义事件，并向上传递消息给父组件。父组件可以通过监听子组件触发的事件，并处理相应的逻辑。
3. 使用事件总线：可以通过创建一个公共的Vue实例作为事件总线来实现组件之间的通信。在某个组件中通过事件总线实例触发事件，其他组件通过事件总线实例监听该事件并执行相应操作，从而实现组件之间的通信。
4. Vuex：可以在不同的组件之间共享数据，并通过定义的 `mutations` 来修改共享状态。



在 `vue3` 中还可以使用



## Vue 兄弟组件如何通信

- 事件总线：EventBus  [Vue.prototype.$bus = new Vue()]
- 全局数据共享：Vuex



**事件总线的原理：** 在 `Vue` 原型上设置一个属性，给这个属性添加一个新的 `Vue` 实例，然后使用 `属性.emit` 传递数据，通过 `属性 .on` 接收数据



## Vue 指令 v-el 的作用是什么

提供一个在页面上已存在的 `DOM` 元素作为 `Vue` 实例的挂载目标，可以是 `css` 选择器，也可以是一个 `HTMLElement` 实例



## Vue 第一次页面加载会触发哪些钩子？

`beforeCreate`、`created`、`beforeMount`、`mounted`



## Vue 获取数据在哪个生命周期函数?

一般在 `created`、`beforeMount`、`mounted` 中， 

如果要操作 `DOM` ，必须在  `beforeMount` 之后才能操作



## Vue 如何去除 URL 中的 #

将路由的 `hash` 模式改为 `history` 模式



## Vue $route 和 $router 的区别

`$router` 为 `VueRouter` 实例，`$route` 为当前路由

一般 `$router` 用于跳转路由  **而**  `$route` 用于接收路由的参数



## Vue 数据双向绑定原理

`v-model` 主要用于双向绑定数据，他给元素绑定时，不同元素做法也不同

1、如果是普通文本类型元素 input / textarea 绑定的是 value / input

2、如果是单选或多选元素 checkbox / redio 绑定的是 checked / change

3、如果是下拉元素 select 绑定的是 change

4、其他表单元素会按照 value / input 处理

 

## Vue v-for 为什么一定要绑定 key ?

在删除数据时，由于没有绑定 `key`，不确定删除的是哪个，就会把整个虚拟 `dom` 重新渲染，这样对性能不太友好。

但如果设置了 `key`，比如 `k` 的值为 `x`，那么在删除数据时候只会把 `dom` 为 `x` 的数据删掉，并不会重新渲染整个 `dom`。这样一来对性能有非常大的提高



## Vue v-show 和 v-if 指令的共同点与不同点

**相同点**

`v-show` 与 `v-if` 都是控制元素的显示与隐藏的

**不同点**

实现本质不同：`v-show` 本质是通过设置 `css` 的 `display：none` 来控制显示隐藏，其实就是在控制 `css`。

而 `v-if` 是动态向 `DOM` 树中添加和删除来控制显示与隐藏的

**总结**

`v-show` 只编译一次，后面其实就是在控制 `css`，而 `v-if` 不停的创建、销毁对性能不好。所以当频繁显示隐藏切换时使用 `v-show`，否则就使用 `v-if`



## Vue 的生命周期有哪些

**Vue2**

**beforeCreate：** 这个阶段还不能访问 `data` 中的属性以及 `method` 中的方法，因为 `Vue` 实例还没有初始化成功。
**created：** 此时 `Vue` 的实例已经挂载完毕，可以访问 `data` 和 `method` 了，一般在这里发起 `axios` 网络请求并赋值给 `data` 中的数据。但是还不能获取或修改 `dom` 元素，因为 `dom` 还没有挂载成功。如果情况特殊，可以使用 `nextTick` 来操作 `dom` 
**beforeMount： ** 此时还是无法获取 `dom`，因为 `dom` 还没有挂载到页面上。
**mounted：** 到这一步 `dom` 就挂载成功了，可以进行操作了。
**beforeUpdate：** 此时 `Vue` 中数据虽然发生了变化，但页面还没开始重新渲染
**Updated： ** 这时候页面重新渲染完成，数据是最新的
**beforeDestroy： ** 此时 `Vue` 实例仍然可用，可以访问 `data`、`method` 等，一般在这里进行一些清理工作或者在销毁之前做一些操作
**destroyed： ** 此时 `Vue` 的实例已经被销毁了，不能再访问 `data`、`method` 等



**Vue2 -> Vue3**

- `beforeCreate` -> 使用 `setup()`
- `created` -> 使用 `setup()`
- `beforeMount` -> `onBeforeMount`
- `mounted` -> `onMounted`
- `beforeUpdate` -> `onBeforeUpdate`
- `updated` -> `onUpdated`
- `beforeDestroy` -> `onBeforeUnmount`
- `destroyed` -> `onUnmounted`
- `errorCaptured` -> `onErrorCaptured`



## Vuex 的出现解决了什么问题

主要解决了以下两个问题 

1、当多个组件依赖于同一状态时，对于层层嵌套的组件之间传值会非常麻烦，并且没办法对兄弟组件之间的传值

2、使用路由传递参数过多时就会导致 `400` 等问题 



## Vue nextTick的作用以及应用场景

等 `DOM` 元素渲染完毕之后，在下一次更新循环结束时自动执行回调函数中的代码

**为什么要在下一次？** 因为本次的 `DOM` 数据还没有更新，在下一次更新结束后 是最新的数据



**应用场景**

1. 如果想要在修改数据后立刻得到更新后的 `DOM` 结构，可以使用 `Vue.nextTick()`

2. 在 `created` 生命周期中操作 `DOM` 



## Vue keep-alive的作用以及应用场景

可以实现组件缓存，当组件切换时只会触发一次组件的生命周期
它具有 `include`、`exclude` 这两个属性，可以有条件的进行组件缓存
两个钩子函数 `activated` / `deactivated` 用来得知当前组件是否处于激活状态



**应用场景**

`keep-alive` 一般用于在组件页面跳转后保留当前位置

比如从首页 到 分类页第一次会加载分类页的生命周期，而在第二次跳转到分类页时候，因为有了组件缓存，所以分类页的生命周期就不会再次触发了，而且能够保留当前分类页的位置



## Vue 一般在哪个生命周期请求异步数据

我们可以在钩子函数 `created`、`beforeMount`、`mounted` 中进行请求异步数据，因为在这三个钩子函数中，`data` 已经创建，可以将服务端端返回的数据进行赋值。

一般推荐在 `created` 钩子函数中请求异步数据，因为在 `created` 钩子函数中调用异步请求有以下优点：

能更快获取到服务端数据，减少页面加载时间，用户体验更好；

并且 `SSR` 不支持 `beforeMount` 、`mounted` 钩子函数，放在 `created` 中有助于一致性。



## Vue 怎么使 watch 立即被调用

 在参数中指定 `immediate: true` 将会在页面加载完毕后立即执行一次 `watch` 中的回调



## Vue 怎么使 watch 深度监听

在参数中指定 `deep: true` 将会开启 `watch` 深度监听



## Vue computed 中的属性名和 data 中的属性名可以相同吗 

不能同名，因为 `computed、data、props` 都会被挂载到 `vm vue` 的实例对象中，所以他们不能同名



## 谈谈Pinia是什么

一个集中式状态管理方案，通常用于管理多个组件共享的状态数据

相比 Vuex 来说 Pinia 的优点：

没有 mutations 流程更简洁

TypeScript支持更加友好

Pinia 模块定义即可使用，不用汇总



## Vue2/3 采用的数据响应式原理分别是？

vue2 采用的是 `Object.defineProperty `

vue3 采用的是 `Proxy`



## params 和 query的区别

## 简述 Vue 的 MVVM模式

## 路由守卫

## 监听组件原生事件



## Vue 最早可以在哪个生命周期发起请求？

